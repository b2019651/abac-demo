00:00:01 如果你像這樣檢查使用者角色來管理權限，那麼你的權限管理方式是錯誤的。在本大師班中，我將講解所有類型的權限系統，從極其簡單、適用於多種應用程式的系統，到許多公司收費數千美元的企業級權限系統，後者甚至可以讓你建立類似 Google Drive 的系統。我將透過多個圖表來展示所有這些系統是如何互動的，並透過程式碼演示，從簡單的到複雜的權限系統，一步步講解，讓你了解

00:00:32 如何將任何權限系統應用到你的應用程式中。歡迎回到「Web 開發簡化」頻道。我是 Kyle，我的工作是簡化 Web 開發，讓你更快開始建立你的夢想專案。我們首先要深入探討的是，為什麼這種基於角色的權限管理方式並不理想，以及它如何迅速演變成一段糟糕且難以維護的程式碼。但在那之前，我想先提一下…非常感謝 Clerk，Clerk 是本影片的贊助商。他們是一家非常棒的身份驗證公司，我在許多不同的專案中都使用過他們的產品。

00:01:03 我建置了這些系統，接下來我會向大家展示如何將所有這些權限系統整合到 Clerk 中。當然，您也可以不使用 Clerk 來使用這些權限系統，它們都可以在 Clerk 之外建置。但我會向您展示如何將它們整合到 Clerk 中，以便向您展示它如何讓很多事情變得更加容易。首先，正如我所提到的，我想談談為什麼這種基於角色的系統並不理想。我這裡有一些非常基礎的程式碼，頁面上有一條評論。如果您是管理員用戶，您可以刪除這條評論，非常簡單。如果我將使用者的角色變更為管理員，您可以看到右側出現了刪除按鈕。

00:01:35 這相對來說很簡單，但是如果…我想新增一個新角色，例如版主。版主應該也有刪除評論的權限，所以現在我需要在這裡新增另一個檢查，看看使用者角色是否等於版主。如果是，或者他們的角色是管理員，那麼刪除按鈕應該會顯示出來。這樣，無論他們擁有哪個角色，都可以刪除評論。但是，現在我可能還希望用戶能夠刪除自己的評論，所以我將在這裡添加另一個檢查，以便我可以指定用戶。 ID 等於作者 ID

00:02:07 ID，所以我們說作者 ID，我們在這裡寫一個常數，作者 ID 等於 1，想像一下這就像評論本身的 ID。現在你可以看到，我有一個用戶創建了這條評論，但如果我是另一個沒有創建這條評論的用戶，你可以看到我無法刪除它。很快你就會發現，這很容易失控，因為現在我有多層 if 檢查，它們都用 or 和 ANS 連接在一起，形成了一個非常複雜的大型查詢。現在，如果我需要更改任何權限，例如，我想更改我的版主可以執行的操作，讓他們

00:02:38 不再能夠刪除這些內容，我需要修改我新增 if 檢查的每一個地方，所以新增和修改權限非常困難。每次你想修改某個使用者或角色的權限時，我都需要修改我的程式碼，而不是修改設定檔或特定的權限檔。我的權限以及所有相關的內容都…對我來說，這些權限幾乎散落在我整個程式碼庫中。因此，我們可以擺脫這種基於角色（RO）的系統，首先要遷移到的權限系統實際上叫做基於角色的存取控制（RBAC）。它聽起來好像一切都與角色有關，

00:03:10 但實際上，我們要切換到基於權限的思考模式。這裡我有一個非常簡單的身份驗證文件，它將為我們處理所有這些不同的權限。例如，在這裡你可以看到，我有一個對象，其中包含我所有的角色以及他們擁有的所有不同權限。通常在這些基於權限的系統中，你需要將使用者能夠執行的每個操作分解為兩部分：操作（例如查看、建立、更新、刪除）和資源（即你要操作的對象，例如評論、待辦事項、產品、部落格、文章等等）。

00:03:41 這些都是資料庫中你要操作的對象，也就是你的資源。而操作則是你要對特定資源執行的操作。通常情況下，當你編寫這些系統時，物件是

你會用冒號分隔它們，這是相當標準的做法。正如你在這裡看到的，我的管理員、版主和使用者的所有不同權限都定義在這個特定位置。如果你願意，你可以將它們移到資料庫中或儲存在任何你想要的地方。我甚至會在我的圖表中向你展示如何在資料庫中儲存其中一些內容，但對於我們特定的用例，為了盡可能簡化一切，我將

00:04:12 直接將所有內容儲存在程式碼中。這樣做的好處在於，它將所有複雜的 if 檢查（用於根據使用者的角色確定使用者可以做什麼和不能做什麼）都限制在這個配置物件中。現在，我只需呼叫名為 `has permission` 的函數即可。它接受一個使用者和一個權限，例如「查看評論」、「建立評論」、「更新評論」等等，它會檢查使用者角色是否具有該權限。所以它所做的就是…用戶角色將從此處的配置中獲取。

00:04:44 它會檢查該權限是否存在，僅此而已。所以我可以替換這裡的所有程式碼，只需寫上“擁有權限”，然後傳入我的用戶，以及我想要執行的操作。在本例中，這將用於刪除一些評論，就像這樣。現在我遇到了一個輸入錯誤，具體來說是因為我的內容與它期望的內容不符。你可以看到，它需要一個字串類型的 ID 和一個角色（role），角色可以是管理員、版主或使用者。所以我將獲取這種類型的 Ro，我將在這裡手動輸入，說明它是一個字串類型的 ID 或角色（role）。

00:05:18 是一個角色（role）。確保它被導入。好了，快速儲存。確保我先從這裡導出它。好了，然後……我們將從正確的文件中導入它，這樣一切就都正常了。現在，如果我擁有例如管理員或版主刪除此內容的權限，您可以看到它運作良好，並且它賦予了我刪除特定內容的權限。現在，它真正方便的地方在於，假設將來我決定版主不能刪除這些內容，我只需要在這個檔案中移除版主的刪除權限即可。

00:05:50 現在，我程式碼中的所有其他位置都將正常工作。例如，如果我有一個顯示按鈕的 UI，一個從資料庫中刪除某些內容的伺服器操作，以及程式碼中的其他地方可以刪除評論，現在我不需要更改所有這些位置。以前，我必須進入每個刪除評論的地方，更新相應的權限，例如“現在移除版主檢查”，但現在我只需在一個特定位置進行更改即可。現在，所有其他檢查刪除評論的地方，版主的權限都將保持不變。現在我沒有權限執行此操作了，您會立即註意到這個系統有一些限制。

00:06:22 這個系統與之前的系統相比有一些限制，主要限制在於我們很難根據我們正在檢查的物件的特定屬性來設定任何類型的角色。例如，我之前說過，與作者 ID 相同的使用者可以刪除此內容。如果我將其改回“用戶”，並確保用戶的 ID 與作者 ID 相同，那麼在我的舊系統中，我可以執行刪除操作。但現在在我的新系統中，我不再擁有這種權限。有幾種方法可以解決這個問題。主要方法是，如果您有一個相當簡單的用例，實際上您所做的只是檢查用戶是否可以刪除自己的內容，

00:06:54 您可以新增一個名為「自身刪除」或「自身其他」的新權限。例如，我們可以設定“自身刪除”，這樣我們就可以刪除自己的評論。這樣，我們就可以說我們可以刪除任何屬於我們自己的內容。我們自己的評論也可以更新，就像這裡一樣。我們也可以更新自己的評論，這樣就完成了。我們也可以對版主做同樣的操作，例如，允許他們刪除自己的評論等等。我們可以設定他們可以刪除任何評論，但只能更新自己擁有的評論，就像這樣。

00:07:25 現在我可以在這裡做一個檢查，看看他們是否可以刪除評論，或者他們是否擁有刪除自己評論的權限。這裡要檢查的是使用者 ID 是否等於作者 ID。讓我把括號都設定好，然後我們來看最終的程式碼。現在我們首先…

檢查他們是否有權刪除任何評論，或者他們是否有權刪除自己的評論，以及這條評論現在是否是他們自己的評論。即使做了所有這些更改，您仍然可以看到，這個系統仍然需要編寫大量程式碼來檢查權限，尤其是在處理「他們是否可以刪除自己的評論」這個問題時。如果我們添加更多限制，例如“只能刪除沒有特定狀態的內容”，想像一下，一篇部落格文章一旦發布，就無法再刪除或更新它。因此，您需要新增另一個檢查，這需要添加更多權限。正如您所看到的，系統很快就會失控。它適用於相對簡單的系統，但一旦系統變得更複雜，它就會變得非常有限。這就是我想討論的最後一個權限系統。

但在深入探討之前，這是一個相當複雜的系統，我們首先需要了解許多與權限相關的其他內容，因此我想先講解一下相關的圖表。我之前已經講過，現在也想向大家展示如何在 Clerk 中實現這個功能，因為目前我們只是把所有用戶物件等等都硬編碼到程式碼裡，這並不理想。所以我想向大家展示如何使用實際的使用者物件來實現這個功能，這樣你們就能在一個更真實的場景中看到它。首先，我們需要在應用程式中設定 Clerk。我已經完成了這一步，但我會向大家展示你需要做的步驟。首先，你需要安裝 Clerk Next.js 套件，因為我使用的是 Next.js，但如果你不是 Next.js 使用者。

00:08:59 你可以安裝任何你需要的 Clerk 套件，但對於 Next.js，我們只安裝 Clerk Next.js 套件。接下來，你需要將整個應用程式包裝在這個 Clerk 提供者中，這樣它就能確保提供所有你需要的使用者驗證功能。你需要將所有環境變數複製到你自己的 EnV 檔案中。然後，你還需要…我們需要設定一個 Webhook，所以在我們的 API 中，我們有一個 Webhook。很多程式碼都直接來自文檔，但本質上我們所做的就是接收一個 Webhook，每當用戶創建時，它都會觸發。

00:09:30 建立事件觸發。上面的程式碼幾乎都是從 Webhook 獲取信息，並確保信息來自 Clerk。然後，在下面的程式碼是我們實際的程式碼，我們會檢查每當建立使用者時，請確保將其角色更新為「使用者」。例如，我們在這裡將他們的角色設定為“用戶”，就像這樣。現在，這將設定他們的公共元資料訊息，這很方便，因為現在我們可以在任何地方使用這個角色，無論是在客戶端還是伺服器端，都無關緊要，我們可以直接在使用者物件上存取該角色。現在，為了確保 Clerk 正常運作，您需要添加到應用程式的最後一項就是中間件檔案。

00:10:01 這是這段文字直接複製自 Clerk 文檔，正如你所看到的，這是 Clerk 的文檔，涵蓋了你需要做的所有事情。正如你所看到的，我們安裝了 Clerk，獲取了環境變量，安裝了中間件，並將所有內容包裝在提供程序中，就完成了，非常簡單。完成這些之後，我們就可以在應用程式中使用 Clerk 了。接下來，我要新增一個非常簡單的登入和註冊按鈕。我只需貼上這段程式碼，我們還要添加一個「已登出」元件以及一個登入按鈕。好了，現在頁面頂部會顯示一個按鈕，允許我們登入或登出。正如你所看到的，

00:10:33 按鈕之所以會顯示出來，是因為我們目前處於註銷狀態。如果我們點擊這個登入按鈕，就可以完成登入程序。你可以看到，我可以繼續使用 GitHub，並授權 Clerk 使用我的 GitHub 帳戶。現在我們已經登入了，正如你所看到的，那個按鈕已經顯示出來了。已經消失了，如果我需要，我可以取得我的使用者 ID，例如，只需在 Clerk 中等待呼叫 off 函數，然後我可以將這個使用者 ID 放在頁面中的任何位置。現在您可以看到我的使用者 ID 顯示了。我想要做的是獲取我公共元資料中的角色，最簡單的方法是將該元資料直接添加到頒發給我用戶的令牌中。

00:11:05 我獲取使用者 ID 的地方叫做會話聲明，它包含了與我的 JWT 令牌相關的所有資訊。現在我想新增我的特定角色，所以我需要返回 Clerk 頁面，在我的實際專案的配置中，向下捲動到會話，然後在這裡我

我可以透過添加任何我想要的資訊來自訂我的會話令牌。如果我點擊編輯，您可以看到我已經新增了一個全新的 R 屬性，這個 Ro 屬性將會取得我的公共元資料角色（role）。

00:11:36 如果您還記得的話，它會在我們的 VS Code 中重置，或者如果尚未設置，它將預設為使用者角色。所以這裡它會從我的元數據中提取角色，或者默認情況下獲取用戶角色。現在，如果我們回到程式碼，看看那個 Webhook，您還記得我在這裡將我的角色設定為使用者嗎？但我可以將其設定為任何我想要的角色，我們稍後可以修改它來展示它的樣子。現在，如果我有會話聲明，我實際上可以在這裡使用它：會話聲明 Dot。您可以看到我得到了角色（role）。角色（role）之所以會出現在我的程式碼中，是因為我在這裡添加了一個特定的類型文件，

00:12:08 它將其添加到我的 Clerk 類型中。這僅適用於使用 TypeScript 的情況。你需要在這裡添加特定的類型，這樣才能獲得自動完成等功能。現在我有了實際的 R 值，可以把它印出來，例如放在 H1 標籤裡。好了，現在在頁面頂部可以看到我的角色顯示為「使用者」。如果需要，我可以手動更新該使用者的角色進行測試。找到該用戶後，向下捲動到他們的公共元數據，點擊編輯，然後把他們的角色改成「管理員」。這裡的角色不應該是一個數組，而應該只是一個普通的角色，就像這樣。我們快速保存一下。

00:12:40 回到這裡，刷新頁面。刷新後，我們應該可以看到角色已經更改為“管理員”。這樣我們就可以輕鬆地在 Clerk 函數中取得角色。現在我們只需要把它直接插入到函數中，就可以刪除整個使用者部分了。我們不再需要這些內容了。現在我們可以直接使用下面的用戶，我們可以傳入任何我們想要的用戶資訊。我在這裡給它一個對象，所以我只需說 const user 等於，我就可以像這樣獲取我的用戶 ID，所以我可以說我的 ID 是我的用戶 ID，我的 RO 是會話聲明。就這樣滾動，然後

00:13:12 嚴格來說，這個會話聲明是可為空的，所以我們在這裡聲明，如果使用者 ID 等於 null 或會話聲明等於 null，這實際上意味著我們沒有登入。所以我要做的就是把這個按鈕的程式碼移到這裡。好了，這樣我就回到我的登入按鈕了。如果我沒有登錄，我可以刪除下面的所有內容。現在我的用戶將擁有一個有保證的 ID 和一個有保證的權限。現在我們可以看到我有一個管理員權限，我的

00:13:43 註解等等。現在我們的程式碼出現了一個錯誤，因為你可以看到按鈕沒有顯示出來。這只是因為我下面的 if 檢查不正確。這也是為什麼隨著系統變得越來越複雜，這個系統開始崩潰的另一個原因。這就是為什麼我稍後會向你展示一個更完整的權限系統。但這裡我們有我們的檢查。是否擁有執行此操作的權限，或者我們是否擁有執行此特定操作的權限，所以我只需要確保將整個頂部部分用括號括起來，就像這樣。然後，如果我們再添加一個括號，刪除下面的括號，快速儲存並刷新，現在應該可以正常工作了。所以，如果

00:14:15 我們是管理員用戶，我們仍然有權刪除此內容。如果我將用戶改回非管理員用戶，快速儲存，並確保用戶 ID 與此作者 ID 明顯不同，他們應該不再擁有刪除權限。正如您所看到的，刪除按鈕已消失。因此，我們已將身份驗證系統與 Clerk 完全同步到此身份驗證系統中。今後，繼續進行整合將非常容易。接下來，我想做的是轉到我提到的所有圖表。這些不同的圖表實際上都是為了執行此操作而建構的。

00:14:47 在資料庫中所以，正如你所看到的，我最初的想法非常簡單：你有一個用戶，這個用戶有一個角色。但這通常還不夠好。因此，我們想要做的是，讓一個使用者擁有多個角色。這我們甚至還沒有實現，但幾乎所有你建立的身份驗證系統都應該為每個使用者提供多個角色。即使你從未為每個使用者分配過多個角色，擁有這種能力也能讓你的系統更加靈活，而且需要編寫的額外程式碼也極少。所以，我們現在有一個圍繞為特定用戶設置多個角色而構建的系統。我們有一個用戶，並且

00:15:19 有一個角色，並且在 t

在這個特定的圖表中，你看到的每一個藍色元素都像是一個普通的表格，例如使用者表和角色表。所有這些綠色的表格就像資料庫中的連接表，一個用戶可以擁有多個角色，一個角色也可以擁有多個用戶，這是多對多的關係。但是，這種方法只能解決一部分問題，因為很多時候你還需要處理更多的事情，例如我們之前提到的權限。如果你使用資料庫式的系統，你會看到資料庫中有一個權限表，每個角色可以擁有多個權限，每個權限也可以被指派多個角色。

00:15:51 我們用程式碼寫了系統，這使得這部分內容更容易理解。當然，你也可以根據需要將其儲存在資料庫中或程式碼中。這就是我們目前的權限系統，它適用於許多用例，但正如你所看到的，它的功能相當有限。如果我們進入權限系統的下一個階段，你會看到我們唯一新增的是一個組織。如果你正在建立任何基於團隊的應用程序，例如 Slack，或者你可能正在…建立類似 Slack 這樣的多租戶應用程序，或者任何用戶可以登入多個不同組織的應用程序，都需要一個組織表，並添加以下資訊：

00:16:23 實際上，資料方面並不複雜，因為你只需要將組織加入角色中，這樣使用者就可以擁有多個角色，每個角色都與特定的組織關聯。例如，如果你在組織 A 和組織 B 中都擁有管理員角色，那麼你在一個組織中可能擁有管理員角色，而在另一個組織中擁有使用者角色。你可以使用一個帳戶登錄，並透過切換登入的組織來訪問所有這些不同的組織。目前，對於這類組織來說，這是一個非常可靠的系統。但是，實際情況要複雜得多。

00:16:54 比這張圖看起來複雜得多，而 Clerk 實際上讓組織管理變得非常簡單。稍後我會示範它的工作原理。下一層權限會變得複雜得多，正如你所看到的，這是這張圖的最終版本。我要向你展示的頂部部分的內容完全相同，但是如果你想要一個類似 Google 雲端硬碟的系統呢？因為在 Google 雲端硬碟上，你可以與他人分享文件、資料夾或其他內容。本質上，你可以為整個組織設定角色，例如我是使用者、我是管理員，或者我可能擁有多個角色，

00:17:26 例如我是銷售代表、我是技術主管，我在我的組織中擁有所有這些不同的角色。此外，我還為組織中的個人資源設定了角色。例如，如果有人在 Google 雲端硬碟中與我共用一個文件，我可能擁有該文件的編輯角色，對另一個文件擁有檢視者角色，甚至可能擁有另一個完全獨立文件的擁有者角色。因此，要建立所有這些不同的連接，這個系統非常複雜。最好的建模方式是這樣的：假設你只有一個特定的內容，

00:17:57 例如，假設你有一個部落格網站，而你整個網站中唯一可以與多個使用者分享的內容就是部落格本身。然後你可以硬編碼，在這裡建立一個連結表，將所有使用者、他們有權訪問的部落格以及角色連結起來。所以這個 R 系統幾乎和上面的組織系統完全相同，只不過這裡是為存取特定資源分配特定角色，而不是為整個組織內的角色分配角色。同樣，我們將所有規則連接到權限，並且在它們之間使用完全相同的權限。就是這樣。

00:18:29 沒錯，它運作良好。現在你可以看到，我能夠授予使用者對系統中特定資源的特定權限。但是，當你需要共享多種不同的內容時，這種方法就開始失效了。例如，如果你有部落格、文件、圖片以及所有其他需要分享的內容，該怎麼辦？你可以複製貼上，再複製貼上，再複製貼上，對每種不同的資源類型都這樣做。但正如你所看到的，這很快就會變得一團糟。所以通常的做法是，你最終會將其簡化為一個通用的規則。表格

00:19:01 你只需要在這個使用者 R 部分設定一些內容，例如類型等於部落格、類型等於檔案等等。這是一個相當複雜的基於規則的系統，接下來我將向你展示如何以更簡單的方式實現它。

與其使用完整的表格系統來完成所有操作，不如使用一種稱為基於屬性的存取控制（ABAC）的技術。 ABAC 的核心思想是，我們每次進行存取控制時都會包含四個不同的部分。

00:19:32 首先是主體（Subject），這幾乎總是用戶對象，也就是嘗試執行我們請求的任何權限的對象。因此，我們有一個特定的主體，表示「我想做某件事」。然後是操作（Action），也就是使用者想要執行的動作，例如刪除、更新、讀取、檢視等等。最後是資源（Resource），也就是使用者想要操作的物件。例如，“我想讀取所有評論”、“我想讀取這些特定的評論”、“我想刪除這條評論”，這就是資源的定義，它指的是用戶正在操作的對象。

00:20:03 最後，第四部分是其他附加信息，例如使用者所屬的組織、環境、位置（例如是否使用手機）等等。可以用來確定您希望特定內容如何呈現。如您所見，這看起來與我們基於角色的存取控制非常相似，但最大的區別在於，每個部分都包含許多屬性。例如，我們的主題/使用者包含使用者 ID、特定角色、建立日期等屬性。我們的資源也包含其他屬性，例如作者 ID。

00:20:34 我們想要檢查的資源包含發布日期等屬性，以及草稿、非草稿等其他屬性。所有這些屬性我們都可以在權限中進行檢查，以確定是否允許執行特定操作。這就是我們將要建置的系統，因為它是迄今為止最靈活的系統，而許多權限公司會收取數千美元的使用費。我將向您展示如何完全免費地建立它。讓我們回到程式碼，在實際處理權限系統之前，我想先談談一些更簡單的權限系統。我們如何處理組織以及如何管理多個角色，而不僅僅是使用者。

00:21:06 現在，在處理組織方面，Clerk 內建了所有這些功能，這非常棒。您甚至可以看到這裡有一個完整的“組織”選項卡。在「配置」部分，我可以設定所有不同的組織設置，特別是我的角色和權限。例如，我可以設定管理員角色、版主角色、使用者角色以及我需要的任何其他角色，我還可以指定所有不同的權限。這裡我們處理的是評論，所以我有刪除評論權限、讀取評論權限、更新評論權限和查看評論權限，我還可以添加所有其他我想要的權限相關內容。

00:21:37 在這裡，Clerk 的另一個非常棒之處在於，它預設添加了一系列權限，這些權限專門用於管理組織。使用者可以創建組織嗎？他們可以添加用戶嗎？他們可以邀請用戶嗎？他們可以刪除用戶嗎？他們可以更新使用者嗎？所有與實際管理組織相關的功能都直接內建於此，這非常方便，因此您無需再進行其他設定。不必擔心這些，因為這真的比你想像的要複雜得多，尤其是當你開始處理邀請用戶、用戶同時登入多個不同組織以及在它們之間切換等操作時。所有這些都由 Clerk 自動處理。

00:22:09 它開箱即用，你只需要確保啟用組織功能，這裡只有一個複選框，勾選它，搞定！現在你的應用程式中就有了組織功能。如果我們想要處理多個角色，這也非常簡單。我們可以進入特定使用者頁面（這將與非組織方式有所不同），我可以將其從 Roll 更改為 rolls，然後將其更改為數組，這樣就可以正常工作了。現在我還需要修改我的程式碼來支援這一點，所以這裡顯示的是 rolles，它將是一個 roll 數組，此外，在
00:22:41 這裡，我需要將其更改為 roll，並將其設定為如果一個數組中預設該使用者只有使用者角色，那麼我需要進一步修改程式碼。這裡會列出所有不同的角色，而這裡檢查使用者是否擁有權限的部分也需要修改，因為它將接收一個包含不同角色的數組，所以我們需要遍歷這些角色，以便傳回結果。

n 個使用者。角色，確保我拼字正確，應該是 rolls。好了，開始求和，對於我的每個角色

00:23:15 我只想返回呼叫這段程式碼，我們只需要傳入角色。確保我用正確的括號把所有內容都括起來。好了，這裡還需要一個括號。快速保存。一切正常。現在最後一步是在我的頁面上。我只想確保我的用戶擁有 rolles 屬性而不是 roll 屬性。保存。然後我們只需要確保它也更新為規則。接下來，我們還需要在這裡配置會話，以確保我們傳遞

00:23:46 rolls 和 rolls。就是這樣，因為我們把所有東西都從 Roll 重新命名為 rolls。不過，如果你是第一次設置，就不需要進行所有這些重命名。現在一切都完成了，我們應該可以刷新頁面了。正如你所看到的，我們在頁面頂部看到了角色。在那裡，如果我們給用戶設定多個規則，這些規則就會顯示在頂部。我們來操作一下。找到我們目前的用戶，編輯一下，新增第二個管理員角色，然後儲存。現在回到這裡，稍等片刻，再刷新一下頁面。好了，現在我們可以看到兩個規則都顯示出來了。

00:24:17 現在，我們要在這裡實作我在影片開頭提到的那個極其複雜的系統。我們直接貼整個文件，然後我會講解裡面的所有程式碼，因為它相當複雜。首先，我們有很多不同的類型，這是為了模擬我們數據中的所有不同類型。我們有待辦事項、評論、使用者和角色。如果我們查看這些類型，可以看到評論有 ID、正文、作者 ID 和創建者 ID。對於已完成的記錄，我們…我們已經完成了用戶 ID、標題 ID 等字段，甚至還有一個包含所有受邀訪問此特定待辦事項的用戶的數組。

00:24:49 這組資料將允許我們做很多事。首先，我們可以檢查：嘿，這是評論的作者嗎？這是創建待辦事項的人嗎？我們可以檢查他們是否受邀存取此特定數據？我們可以檢查此待辦事項是否已完成？所有這些功能都可以在我們的系統中使用。此外，對於角色，您可以看到我們有管理員、版主和用戶，就像之前一樣。但是對於用戶，我添加了一個額外的欄位“被封鎖者”，這樣我們就可以阻止特定用戶。再次強調，我們可以執行所有這些複雜的身份驗證和權限相關的操作。我們可以根據以下條件設定權限：

00:25:20 他們是否受邀？他們是否被阻止？待辦事項是否已完成？他們是此特定事項的作者嗎？所有這些都由系統輕鬆處理。回到頂部的“關閉”部分，我這裡有一些相當複雜的 TypeScript 程式碼。這段 TypeScript 程式碼的作用是，當我們在下面定義所有…我們擁有不同的角色，因此我們獲得了完整的類型安全。例如，如果我刪除一些內容，然後進入這裡，可以看到我的評論在這裡獲得了類型安全。在這裡，我可以建立、更新或查看。當我定義這個建立、更新或檢視操作時，我可以傳遞一個布林值（例如 true 或 false），也可以傳遞一個函數。

00:25:51 這個函數也具有完整的型別安全性。例如，如果我進入這裡並訪問我的用戶，我會獲得所有用戶類型的安全；如果我訪問我的評論，我會獲得所有評論類型的安全。這就是頂部這段 TypeScript 程式碼的全部作用。現在我把這段程式碼恢復到之前的狀態。所以不用太擔心，這只是一些複雜的 TypeScript 程式碼來實現所有這些功能，它可能寫得併不好，因為我的 TypeScript 等級並不高。接下來是這個名為「權限」的類型，你可以在這裡定義應用程式中的所有不同權限。例如，我們的第一個權限是用於評論的。

00:26:22 以及我把這個拆開來，關鍵在於資源。在這個四步驟系統中，我提到了資源，所以這就是我們的資源—評論。然後我指定評論的類型。這僅適用於 TypeScript，因為 TypeScript 可以提供良好的自動完成功能。所以我指定了評論的類型。在這個待辦事項中，你甚至可以看到，例如，如果我只想取得 ID 部分，我可以只寫作者 ID。這樣，我就只能存取這些函數中的 ID 了。所以，每當我向下滾動到評論時，你可以看到我只能訪問作者 ID。我可以根據需要進行限制。在我的例子中，我將其保留為：

00:26:54 完整評論。然後我可以指定所有不同操作的清單。

例如，這個權限只能用於檢視、建立和更新。我什至沒有刪除評論的選項，因為在這個特定用例中，我的應用程式無法執行此操作。同樣，這裡我們有一個待辦事項，這個權限允許我們查看、建立、更新和刪除。因此，我們可以非常精細地調整每個不同權限的功能。您只需定義您的權限即可。例如，管理員的評論權限設定為“全部”，待辦事項的權限也設定為“全部”。版主可以對評論執行所有操作，但對於待辦事項，例如，他們可以查看、建立和更新任何待辦事項，但

00:27:25 只能刪除已完成的待辦事項。現在，這種基於物件實際屬性執行操作的能力，只有在基於屬性的存取控制系統中才有可能。在我們之前的基於角色的權限系統中，我們無法根據物件的屬性執行操作，這需要我們進行非常複雜的檢查。但現在，所有這些資訊都定義在我的權限中。系統方面，我的所有檢查都將簡化到極致，權限管理也全部都在這個文件中完成。用戶部分的情況則複雜得多，因為現在我可以

00:27:56 檢查很多不同的事項。例如，用戶可以建立任何評論，但只能查看未被封鎖用戶的評論。如果一個用戶封鎖了另一個用戶，那麼被封鎖的用戶就無法再看到這些評論。用戶還可以更新任何評論，只要他們是評論的作者。如果我們看一下待辦事項部分，可以看到使用者可以查看任何待辦事項，只要它沒有被其他人封鎖。如果用戶沒有封鎖他們，他們就可以查看。他們可以更新任何他們自己創建的待辦事項，或任何他們被其他使用者邀請參與的待辦事項。最後，他們可以刪除任何他們擁有特定 IDE 權限的待辦事項，或任何他們被其他使用者邀請參與的待辦事項。

00:28:27 他們可以刪除待辦事項，但只能刪除「已完成」屬性設定為 true 的待辦事項。所以，我在這裡示範了很多操作，向你們展示它的靈活性。當然，你們可以根據自己的需求調整彈性，完全取決於你們自己。你們幾乎可以對使用者、評論運行任何想要的 JavaScript 程式碼，也可以在這裡傳遞任何其他資訊。我這裡只是做了一個相對簡單的演示，但你們可以看到它的功能非常強大，可以實現很多操作。我們這裡的「擁有權限」函數略有改動，因為現在我們需要像之前一樣，把使用者資訊傳遞給它。我把資源和

00:28:59 操作分成了兩個獨立的部分。所以現在我們可以傳遞一些類似這樣的訊息，像是「擁有權限」。我們會把使用者資訊傳遞給它，然後是資源訊息，最後是操作訊息。所以它會被分成兩個獨立的參數。最後，如果你願意，你還可以傳遞一些數據，這裡的數據是一個評論對象。所以我也可以傳遞我自己的評論對象。如果我不傳遞任何內容，它會檢查我是否有權更新所有內容。資料庫中的單一註釋，如果我傳遞一個特定的對象，它就問：我是否有權限更新這個對象？

00:29:30 特定對象，所以這個系統的工作方式非常有彈性。要不要我示範一下它是如何運作的？我回到這裡的程式碼，把這裡的內容全部刪除，貼上一些新程式碼，然後給你展示這段程式碼的樣子。我還需要確保我修改了上面的一個導入語句，它會從正確的檔案導入。確保這裡的所有內容都已保存。現在，如果我們回到這個頁面，你可以看到最頂部有一個待辦事項清單。我把它拉寬一點，這樣你就能清楚地看到裡面的內容。稍微縮小一點，好了。這應該很容易理解。

00:30:01 可以看到，我有一個包含各種待辦事項的列表，它們在右邊。所以第一個待辦事項的 ID 為 1，由 ID 為 1 的使用者創建，尚未完成，也沒有人邀請。 ID 為 2 的待辦事項也是由 ID 為 1 的使用者所建立的。因此，第一行的這兩個待辦事項都由 ID 為 1 的使用者創建，它們的狀態要么是已完成，要么是未完成。如果是 X，則表示未完成；如果是勾號，則表示已完成。接下來的兩個待辦事項由 ID 為 2 的使用者建立。最後一個待辦事項（也就是最後一個）已由使用者 1 和 3 邀請。所以用戶 1

00:30:32 和 3 受邀參與了這個待辦事項。現在我正在定義我的用戶，我暫時用卡片編碼的方式進行編碼，接下來我們將實作 Clerk 功能。

稍後我會詳細說明，但這樣我更容易操作資料進行演示。最後，我還有一些不同的按鈕檢查，例如這個「常規」按鈕檢查。如果我們向下捲動到該函數，可以看到它所做的就是呼叫「權限」函數，並將我的使用者、我的資源和操作傳遞給它。如果可以執行該操作，它會顯示一個藍色按鈕；如果不能，它會顯示一個紅色按鈕。所以，在最上面，我正在檢查是否可以對資料庫中的所有待辦事項執行查看、建立、更新和刪除操作。

00:31:03 這只是一個常規的待辦事項檢查。正如你所看到的，ID 為 3 的用戶角色是“用戶”，他們無法查看所有待辦事項，可以創建任何他們想要的待辦事項，但無法更新或刪除所有待辦事項。現在，如果我將此角色更改為“管理員”，然後保存，你會看到“管理員”的所有選項都變成了藍色，因為管理員幾乎擁有所有操作的權限。在我們的應用程式中，接下來我要做的就是遍歷每個待辦事項，並在每個待辦事項中添加三個獨立的按鈕，分別檢查：

00:31:35 使用者是否擁有檢視、更新和刪除該待辦事項的權限。如果我們查看權限檢查的程式碼，可以看到它傳遞了我的使用者訊息，傳遞了我要檢查的內容（在本例中是待辦事項），傳遞了我要檢查的操作（查看、刪除、更新等等），最後傳遞了具體的待辦事項。這樣可以確保執行所有這些額外的檢查。如果我回到這裡，我可以看到我傳遞了我的待辦事項，它會呼叫包含所有程式碼的特定函數。現在讓我們回到這裡，真正體驗這個權限系統的靈活性。

00:32:06 因為如果我們進入這裡，假設我們是 ID 為 1 的用戶，然後快速保存，可以看到… ID 為 1 的用戶可以查看所有這些不同的內容，他們可以查看所有待辦事項，這沒問題，因為他們沒有被任何人封鎖。他們可以更新自己建立的待辦事項，也可以刪除自己建立的、標記為已完成的待辦事項。您可以看到，他們被邀請參與了下面的這個待辦事項，所以他們也可以更新和刪除這個待辦事項。但是對於使用者 2 建立的這個待辦事項，他們沒有權限進行任何操作，所以您可以看到更新和刪除操作都被封鎖了。

00:32:37 現在我們來看看使用者 3。您可以看到使用者 3 擁有這個待辦事項的特殊存取權限，因為他們被邀請了。假設他們實際上被用戶 2 封鎖了。如果我們快速保存一下，您現在可以看到他們無法查看用戶 2 創建的任何內容，因為他們被該用戶封鎖了。同樣，如果我們來看用戶 1，您可以看到他們無法查看這裡的任何訊息，因為他們被該用戶封鎖了。如果我們的使用者擁有多個角色，例如版主，我們不希望版主被其他人封鎖。所以，如果版主是這裡實際的角色，你可以看到他們

00:33:08 即使被屏蔽，仍然可以查看內容。因為他們是版主，所以他們應該能夠繞過屏蔽。這就是我們設立版主的初衷。你可以看到這個人擁有多個角色。我們現在正在檢視多角色機制是如何運作的。使用 Clerk 實作這個功能相對簡單。我們只需要確保再次取得會話聲明，所以我們可以使用 `const session claims`，這相當於呼叫 `off` 函數。這是一個非同步函數，所以請確保在這裡加上 `async`。我們等待它執行。我還要獲取

00:33:40 用戶 ID。好了。我在這裡聲明，如果會話聲明等於 null 或使用者 ID 等於 null，那麼我將返回登入按鈕。所以我快速複製一下這個按鈕。好了。現在我們有了我們的登入按鈕，最後我們可以獲取用戶信息，所以我們可以說用戶等於 ID，ID 就是我們的用戶 ID，角色就是你的會話。

00:34:12 聲明。角色，就是這樣。然後我們可以說我們被用戶封鎖了，我在這裡把它叫做什麼來著？被阻止了，就是這樣。我們再說一下，他們沒有被任何人阻止。你可以從資料庫中獲取這個信息，也可以從會話聲明中獲取，幾乎可以從任何地方獲取。但現在，使用我們的用戶對象，一切都應該正常運作了。只需確保我們將用戶傳遞到所有需要的地方即可。所以我要做的是，將我的用戶作為屬性傳遞給所有這些。

00:34:44 因為我們需要存取它，而且是相同的。

這裡我要把它傳遞給我的待辦事項，這樣我們就可以說這個待辦事項函數會接收我所有的待辦事項屬性以及一個使用者。現在我們先把它輸入為 any，這樣可以避免所有輸入錯誤。所以這裡是 any 和 to do，也就是 to do 和 to do 這個特定的輸入。你只需要像這樣輸入，就能解決所有問題。然後這裡也是一樣，我要傳入一個用戶，然後我

00:35:16 給它類型設定為 any，這可以避免所有 type 腳本的問題，因為這些現在都不重要。最後一步是把我的用戶傳過來。好了，貼到這裡。在這裡，我們要再次傳遞一個用戶，類型暫時設定為 any。我相信我上面犯了一個錯誤，這裡不應該有 type 行，這應該可以解決我們的問題。好了，你可以看到這個使用者擁有使用者和管理員的角色，所以他們有權限存取所有內容，因為他們是管理員。但是如果我們想要…修改用戶設置，使其不再擁有管理員權限。我們來移除這個管理員權限。

00:35:48 現在移除管理員權限，然後快速儲存。回到這裡，稍等片刻，我們刷新一下。現在可以看到，我們是一個普通用戶，用戶 ID 與這些用戶 ID 都不匹配，所以我們無法更新或刪除任何用戶。我們可以查看這些用戶，因為我們沒有被任何人封鎖。我當然可以修改設置，例如設定我們被用戶一屏蔽，這樣我就無法查看用戶一的內容，但仍然可以查看用戶二的內容。我知道我在視頻中快速講解了代碼，所以如果你想深入了解這些權限系統，我會提供一個 GitHub 倉庫的鏈接，其中包含了所有這些不同的權限系統，你可以

00:36:19 去修改它們，閱讀它們，了解它們的具體功能。另外，如果你喜歡 Clerk，並且想了解一個真正優秀的身份驗證系統，它能讓身份驗證變得極其簡單，讓你再也不用為此操心，我強烈推薦你試試 Clerk，我非常喜歡它。我會在我的各種項目中使用它，我會在下面的描述中留下連結。最後，非常感謝您的觀看，祝您愉快！