00:00:01  如果你正在這樣檢查用戶角色的權限，那麼你就是在錯誤地處理權限。在這堂大師班中，我將會介紹市面上每一種權限系統，從非常簡單且適用於許多應用程序的系統，一直到許多公司收取數千美元的企業級權限系統，然後你可以用這些系統構建類似 Google Drive 的克隆。我將通過多個不同的圖表來展示這些不同系統之間的互動，並進行從簡單到極端的權限系統的代碼演示，讓你了解所有這些內容。

00:00:32  如何為您的應用程式使用任何權限系統 歡迎回到 Web Dev Simplified，我的名字是 Kyle，我的工作是為您簡化網頁，以便您可以更快開始構建您的夢想專案。我們將深入探討的第一件事是，為什麼這種基於角色的權限處理方式並不理想，以及它如何迅速演變成一段糟糕且難以維護的程式碼。但在此之前，我首先想要對 Clerk 表示衷心的感謝，Clerk 實際上是這段影片的贊助商，他們是一家非常出色的身份驗證公司，我在許多不同的專案中都使用他們的服務。

00:01:03  我已經建立了系統，接下來我將向你展示如何將這些權限系統整合到 Clerk 中。如果你想的話，你不必使用 Clerk 來使用這些權限系統，它們都是在 Clerk 之外建立的，但我會告訴你如何將它們整合進 Clerk，以便讓這些事情變得更簡單。首先，正如我提到的，我想談談為什麼這種基於角色的系統並不理想。很快地，我這裡有一些非常基本的程式碼，我在一個頁面上有一個評論，如果你是管理員用戶，你就有能力刪除這個評論，非常簡單。如果我將上面用戶的角色改為管理員，你可以看到右側出現了刪除按鈕。

00:01:35  這段話相對簡單，但如果我想添加一個新的角色，例如版主，會發生什麼呢？版主可能應該有刪除評論的能力，因此我現在需要在這裡添加另一個檢查，以查看用戶角色是否等於版主。如果這是真的，或者他們的角色是管理員，那麼刪除按鈕應該顯示出來。現在不管他們擁有哪兩個角色，都可以刪除這個評論，但我也可能希望用戶能夠刪除自己的評論，所以我將在這裡添加另一個或檢查，這樣我可以說用戶ID等於作者。

00:02:07  ID，所以我們會說作者 ID，我們就來這裡定義 const author ID 等於 1，想像這就像是實際評論的 ID。因此，現在你可以看到我有一個用戶創建了這條評論，但如果我是另一個沒有創建這條評論的用戶，你現在可以看到我無法刪除它。而且你可以很快看到這是如何輕易失控的，因為現在我有多層的 if 檢查，全部用 or 和 AND 連接在一起，讓這個查詢變得非常複雜。如果我需要更改任何權限，例如我想更改我的版主可以做的事情，讓他們可以不再...

00:02:38  刪除這些東西我需要來到我添加這個檢查的每一個地方，我需要改變這一點，因此添加和修改權限變得非常困難，每次想要修改某個用戶或角色的權限時，我需要進入我的實際代碼並進行更改，而不是進入像配置文件或特定權限文件那樣的地方，所以我的權限以及所有相關的東西在整個代碼庫中都是零散的。因此，我們可以轉向的第一個權限系統，以擺脫這種基於角色的系統，實際上稱為基於角色的訪問控制（RBAC），這聽起來可能像是所有的東西。

00:03:10  與角色相關，但我們現在轉向基於權限的思維方式，因此這裡我有一個非常簡單的身份驗證檔案，實際上將為我們處理所有這些不同的權限。例如，您可以看到我有一個物件，裡面包含了我所有的角色及其擁有的不同權限。一般來說，在這些基於權限的系統中，您將把每個人可以做的事情分解為兩個部分：一是動作，例如查看、創建、更新、刪除；二是資源，即您正在操作的對象，例如評論、待辦事項、產品、博客、文章等等。

00:03:41  在你的資料庫中，有些事情是你想要進行操作的，這將成為你的資源，而行動則是你想對該特定對象執行的操作。一般來說，當你編寫這些系統時，你會用冒號將它們分開，這是一個相當標準的做法。正如你在這裡看到的，我的管理員、版主和用戶所擁有的所有不同權限都在這個特定位置中定義。如果你想的話，可以將這些移到資料庫中或存放在任何你想要的地方。我甚至會在我的圖示中向你展示如何將其中一些存儲在資料庫中，但為了我們特定的使用案例，為了保持一切盡可能簡單，我將只會……

00:04:12  現在直接將所有內容儲存在代碼中，這樣做的原因是因為它將所有這些複雜的條件檢查簡化為一個配置對象，以查看用戶可以做什麼以及不能做什麼，這樣我只需調用一個名為 has permission 的函數。這個函數的作用是接受一個用戶和一個權限，例如查看評論、創建評論、更新評論，無論我想做什麼，它都會檢查該權限在用戶角色中的有效性，以確定是否擁有該特定權限。因此，它只需獲取用戶的角色，然後從這個配置中獲取角色。

00:04:44  它將檢查這個權限是否存在於其中，這就是它要做的所有事情。因此，我可以替換掉這裡的所有代碼，只需說「has permission」，然後傳入我的用戶和我想要執行的操作。在我們的案例中，這將用於刪除一些評論，就這樣。現在我遇到了類型錯誤，具體是因為我的內容與它所期望的所有內容不一致。你可以看到這裡期望一個字符串類型的 ID 和一個角色，這些角色是管理員、版主或用戶之一。因此，我將獲取這種類型的角色，然後手動輸入這個類型，說明它是一個字符串類型的 ID 或一個角色。

00:05:18  是個滾動，確保我們將其導入，來吧，快速保存一下，確保我實際上先從這裡導出，來吧，然後我們將從正確的文件導入，這樣應該都能正常運作。所以現在如果我有能力，例如作為管理員或作為版主來刪除這個，你可以看到這樣運作得很好，並且給我實際刪除那個特定項目的權限。現在再次強調，讓這個功能真的很棒的是，假設將來我決定，版主其實不能刪除這些，我所要做的就是進入這個文件，移除版主的刪除權限。

00:05:50  要刪除，現在我程式碼中的其他所有位置都會正常運作，因此如果我有一個顯示按鈕的用戶介面，我有一個伺服器動作從我的資料庫中刪除某些東西，並且在程式碼的其他地方有可以刪除評論的地方，我現在不需要像以前那樣更改所有這些位置。以前我必須去每個刪除評論的地方，更新特定的權限，說好吧，現在移除這個版主檢查，但現在我只需在一個特定的位置進行更改，現在其他所有檢查刪除評論的地方，版主不再有權限這樣做。你會立即注意到這裡有一些限制。

00:06:22  這個系統與我們之前的系統不同，主要的限制是我們很難根據我們正在檢查的物件的特定屬性來執行任何類型的角色。例如，最初我說過，與作者 ID 相同的用戶 ID 能夠刪除這個項目。因此，如果我將這個設置改回用戶，並確保用戶的 ID 與我舊系統中的作者 ID 相同，我就能夠執行這個刪除操作，但現在在我的新系統中，我不再具備這種能力。為了解決這個問題，有幾種方法，主要的方法是如果你有一個相對簡單的用例，實際上你所做的只是檢查是否可以。

00:06:54  他們刪除自己的東西是你可以新增一個叫做「擁有刪除」或「擁有任何」的權限，所以舉個例子，我們可以說「擁有刪除」，抱歉，刪除，我們想刪除自己的評論，這樣可以，所以我們可以刪除任何東西，只要是我們自己的評論。同樣的，我們可以對自己的評論進行更新，這樣可以。我們也可以對我們的版主做同樣的事情，例如說他們可以刪除自己的評論等等，我們會說他們可以刪除任何評論，而他們只能更新自己擁有的評論，就這樣。

00:07:25  現在我可以在這裡進行檢查，我可以說好，他們可以刪除評論嗎？當然可以，或者他們是否有權限刪除自己的評論？這是針對刪除他們自己的評論，我們需要確保檢查在這裡，使用者 ID 是否等於作者 ID。讓我把我的括號都設置好，我們可以看看這段最終的代碼。現在我們首先檢查他們是否有權限刪除任何評論，或者他們是否有權限刪除自己的評論，這條特定的評論是否是他們自己的評論。即使有這些所有的條件，

00:07:56  您可以看到這個系統仍然有很多代碼需要編寫來檢查權限，尤其是當我們處理用戶是否可以刪除自己的評論時。如果我們還要添加更多條件，比如說您只能刪除沒有特定狀態的項目，那麼想像一下，當一篇博客文章達到已發佈狀態後，您就無法再刪除或更新它，因此這又是您需要添加的一個檢查，這需要您添加更多的權限。正如您所見，系統很快就會失控，對於相對簡單的系統來說，它運作得很好，但一旦變得更複雜，就變得非常有限。這就是我想談論的最終權限系統的所在。

00:08:28  在我們進入這個話題之前，這是一個相當複雜的系統，我們首先需要了解許多與權限相關的其他事物。因此，我想回顧一下我提到的許多圖表，並且我還想向你展示如何在 Clerk 中實現這個功能。因為目前我們只是硬編碼了所有的用戶對象等等，這並不是理想的做法，所以我想展示如何使用實際的用戶對象來實現這一點，這樣你就可以在更真實的場景中看到這個過程。我們需要做的第一件事就是在我們的應用程序中設置 Clerk。我已經完成了這一步，但我會告訴你需要做什麼。你需要做的第一件事是安裝 Clerk 的 Next 套件，因為我在使用 Next.js，但如果你不是在使用 Next.js...

00:08:59  你可以隨意安裝任何你需要的 Clerk 套件，但對於 Next.js，我們只需安裝 Clerk 的 Next.js 套件。接下來，你需要將整個應用程序包裹在這個 Clerk 提供者中，這樣可以確保提供你所需的所有不同用戶身份驗證功能。你需要將所有環境變數複製到你自己的 EnV 文件中，然後你還需要設置一個網絡鉤子。在我們的 API 中，我們有一個網絡鉤子，這些代碼大部分來自文檔，但基本上我們所做的就是每次有用戶時接收一個網絡鉤子。

00:09:30  創建事件被觸發，這段代碼主要是從我們的網絡鉤子獲取所有信息，並確保它來自 Clerk。然後在這裡我們進行實際的代碼，所以我們只是在檢查每當一個用戶被創建時，我們確保更新他們的角色為用戶。因此，讓我們進來這裡，說他們的角色將是用戶，就這樣。現在這將設置他們公共元數據上的信息，這很好，因為現在我們可以在任何地方使用這個角色，無論是在客戶端還是服務器上，這真的無所謂，我們將能夠直接在用戶對象上訪問角色。最後，你需要添加到你的應用程序中的一件事，以確保 Clerk 正在運作，就是你的中介軟件文件。

00:10:01  這段文字直接從Clerk的文檔中複製過來，如您所見，這是Clerk的文檔，涵蓋了您需要做的所有事情。如您所見，我們安裝了Clerk，獲取了環境變數，設置了中介軟體，並將所有內容包裝在提供者中，這就是全部，我們已經完全完成了。因此，這相當簡單。一旦完成這些，我們就可以在應用程式中使用Clerk。接下來，我將添加一個非常簡單的登入和註冊按鈕，所以我將粘貼這個特定的部分，我們將添加這個登出組件以及這個登入按鈕。好了，現在這將在我們頁面的頂部提供一個按鈕，讓我們可以登入或登出。

00:10:33  可以看到這個按鈕出現是因為我們目前已經登出，如果我們點擊這個登入按鈕，就可以進入登入的過程。你可以看到我可以選擇使用 GitHub 繼續，並表示我想授權 Clerk 使用我的 GitHub 帳戶。現在我們實際上已經登入了，正如你所見，那個按鈕已經消失。如果我想要的話，我可以通過說我想等待從 Clerk 調用 off 函數來獲取我的用戶 ID，我可以將那個用戶 ID 放在我的頁面中的任何地方。現在你可以看到我的用戶 ID 正在顯示。我想做的是獲取我公共元數據中的角色，最簡單的方法就是直接添加那個元數據。

00:11:05  對於我發給用戶的令牌，我在獲取用戶 ID 時，有一個叫做會話聲明的東西，這是與我的 JWT 令牌相關的所有信息。現在我想添加我的特定角色，所以我需要回到 Clerk 頁面，在我的實際項目的配置中，我需要向下滾動到會話，在這裡我可以通過添加任何我想要的信息來自定義我的會話令牌。如果我點擊編輯，你可以看到我已經這樣做了，我添加了一個全新的 R 屬性，而這個 Ro 屬性將獲取我的公共元數據角色。

00:11:36  如果你記得正確的話，這會在我們的 VS Code 內部重置，否則它會默認為用戶角色，如果尚未設置的話。所以這裡它只是會從我的元數據中提取，或者他們會默認獲得用戶角色。現在如果我們回到代碼中，查看那個網絡鉤子，你記得我在這裡將我的角色設置為用戶，但我可以將其設置為我想要的任何內容，我們可以稍後修改它來顯示那會是什麼樣子。但現在如果我有那個會話聲明，我實際上可以在這裡使用它，會話聲明點，你可以看到我得到了角色。現在角色對我來說顯示出來的原因是因為我在這裡添加了一個特定類型的文件。

00:12:08  將以下文本翻譯成繁體中文：添加到我的職員類型中，這只是如果你正在使用 TypeScript，你會想要在這裡添加特定的類型，以便獲得自動完成等等，所以現在我有我的實際 R，我可以像在 H1 裡面那樣打印出來，這樣在我頁面的最上方你可以看到我的角色顯示為用戶。現在如果我想的話，我可以手動更新該用戶的角色以進行測試，所以我可以找到那個特定的用戶，向下滾動到他們的公共元數據，點擊編輯，讓我們把他們的角色改為管理員，這不應該是一個數組，這應該只是像這樣的一個普通角色，所以我們快速保存一下，我們會來。

00:12:40  回到這裡，刷新我們的頁面，當我們刷新後，我們應該會看到我們的角色現在已經變成管理員，因此我們能夠輕鬆地在Clerk中獲取角色。現在我們需要做的就是將其直接插入到我們的函數中，這樣我們基本上可以去掉這整個用戶部分，我們不再需要任何這些，現在我們可以在這裡使用我們的用戶，這樣我們可以傳入我們想要的任何內容作為用戶。我會給它一個對象，所以我會說const user等於，我可以這樣獲取我的用戶ID，所以我可以說我的ID是我的用戶ID，而我的RO是session claims.roll，就這樣。

00:13:12  從技術上來說，這個會話聲明是可為空的，所以我們只需進入這裡，並說如果用戶 ID 等於 null 或者如果會話聲明等於 null，這基本上意味著我們沒有登入。因此，我要做的是將這個按鈕的代碼移到這裡。好了，所以如果我沒有登入，我只會返回我的登入按鈕，我可以刪除下面所有的內容，現在我的用戶將擁有一個保證的 ID 和一個保證的 Ro 在裡面。所以現在我們可以看到我有一個管理員角色，我有我的。

00:13:43  現在我們的程式碼出現了錯誤，因為你可以看到按鈕沒有顯示出來，這只是因為我這裡的 if 檢查不正確，這也是為什麼這個系統在變得更複雜時開始崩潰的另一個原因。因此，我將在稍後向你展示一個更完整的權限系統。不過在這裡，我們檢查是否有權限執行這個操作，或者是否有權限執行這個特定的操作。所以我只需要確保將整個頂部部分包裹在括號內，就像這樣。然後如果我們再添加一個括號，刪除那裡的括號，快速保存一下，然後刷新，我們應該會看到這樣就可以正常運作了。

00:14:15  我們是管理員用戶，我們再次有能力刪除這個。如果我過來這裡，將我的用戶改回非管理員用戶，快速保存一下，我們會確保用戶 ID 明顯不同於這個作者 ID，他們將不再有刪除的能力。如你所見，刪除按鈕已經消失了。因此，我們已經將我們的身份驗證系統與 Clerk 完全同步到這個特定的身份驗證系統，未來將非常容易繼續進行這種整合。接下來我想做的事情是轉到我提到的所有圖表，所以這些不同的圖表實際上是圍繞這個來構建的。

00:14:47  在資料庫內部，正如你所看到的，我最開始的想法非常簡單，就是你有一個用戶，而這個用戶有一個角色。這通常是不夠的，因此我們想要從這個基礎上進一步發展，使每個用戶擁有多個角色。這是我們尚未實現的，但幾乎每個你建立的身份驗證系統都應該具備每個用戶擁有多個角色的功能，即使你從未為每個用戶分配超過一個角色，擁有這種能力使得你的系統更加靈活，而你需要編寫的額外代碼非常少。因此，我們有一個圍繞特定用戶擁有多個角色而建立的系統，所以我們有一個用戶，然後我們……

00:15:19  在這個特定的圖示中，您所看到的每一個藍色物件就像是一個普通的表格，我們有一個用戶表和一個角色表，所有這些綠色表格就像是資料庫中的聯結表，因此一個用戶可以擁有多個角色，而一個角色也可以擁有多個用戶，這是一種多對多的關係。不過，這樣的設計只能幫助您到此為止，因為很多時候您還需要處理更多的內容，即我們所談到的權限。如果您使用資料庫風格的系統，您可以在資料庫中看到一個權限表，每個角色可以擁有多個權限，而每個權限也可以指派給多個角色。

00:15:51  我們在程式碼中編寫了我們的系統，這使得這個特定部分稍微簡單一些，但你仍然可以根據自己的需求在程式碼中將其存儲在數據庫中。這基本上就是我們目前的權限系統，它對許多使用案例來說運作良好，但正如你所見，它的功能相當有限。如果我們進入下一級的權限系統，你會看到我們唯一添加的就是一個組織。基本上，如果你正在構建任何基於團隊的應用程式，比如 Slack，或者你正在構建像多租戶應用程式，類似於 Slack 的任何應用程式，讓用戶可以登入多個不同的組織，你將需要這個組織表格。

00:16:23  這其實在數據方面並不是太複雜，因為你所要做的就是將組織添加到角色中，這樣用戶可以擁有多個角色，而每個角色都與特定的組織相關聯。例如，如果你在組織A和組織B中，你可能在一個組織中擁有管理員角色，而在另一個組織中擁有用戶角色，你可以使用一個帳戶登錄，並通過切換當前登錄的組織來訪問所有這些不同的組織。這對於這類組織來說是一個非常可靠的系統。

00:16:54  比這個圖表看起來更複雜，而文員實際上使組織處理變得非常簡單。我會在稍後向你展示這是如何運作的。下一級的權限變得極其複雜，正如你所見，這是我將要展示給你的圖表的最終版本。頂部部分的一切完全相同，但如果你想要一個像 Google Drive 系統的東西會發生什麼呢？因為在 Google Drive 上，你可以與人分享文件，可以與人分享資料夾，可以與其他人分享東西。因此，基本上你有一個整個組織的角色，比如我是一個用戶，或者我是一個管理員，或者我可能有……

00:17:26  多重角色，例如我是一名銷售代表，同時也是技術負責人，我在我的組織中擁有這些不同的角色，但我也為該組織中的個別資源擁有角色。例如，如果有人在 Google Drive 中與我分享一個檔案，我可能在該檔案上擁有編輯者角色，而在另一個檔案上擁有檢視者角色，或許在另一個完全不同的檔案上擁有擁有者角色。因此，這個系統在處理所有這些不同的連結時非常複雜，最佳的建模方式是這樣的，如果你只有一個特定的事物。

00:17:57  你在分享，例如假設你有一個部落格網站，而你整個網站中唯一可以分享給多個用戶的就是部落格，那麼你可以在這裡硬編碼，讓這裡有另一個聯接表，將所有用戶、他們可以訪問的部落格以及角色連接在一起。因此，這個 R 系統幾乎與上面的組織系統相同，但這裡是給我們特定的角色來訪問個別資源，而不是整個組織內的角色。這裡的情況也是一樣，我們將所有的規則連接到我們的權限上，並且在它們之間使用完全相同的權限。就這樣。

00:18:29  對，這樣會運作得很好，但現在你可以看到我能夠給用戶特定的權限來訪問我系統內的個別資源。不過，當你需要分享多個不同的東西時，這就開始變得複雜了。例如，如果你有部落格、文件和圖片以及其他需要分享的東西，那會怎樣呢？你可以只是複製這個，然後粘貼下去，再複製，然後再粘貼下去，對每一種不同類型的資源這樣做。但如你所見，這樣會很快變得一團糟。因此，通常最終的結果是你會把這個基本上變成一個通用的表格。

00:19:01  而你所做的就是讓這個用戶 R 區域內顯示一些類似於「類型等於博客」、「類型等於文件」、「類型等於其他」的內容。這是一個相當複雜的基於規則的系統，我將向你展示我們如何以更簡單的方式來實現這一點，而不必使用這個完整的表格系統來處理所有事情，這就是通過使用稱為屬性基礎訪問控制（attribute based access control，簡稱 ABAC）的東西。屬性訪問控制的整個理念是，我們將在每一次檢查中有四個不同的部分。

00:19:32  我們首先要討論的主題幾乎總是用戶對象，這是試圖執行我們所要求的任何權限的事物。因此，我們有一個特定的主體，它說我想做某件事。接著，我們有行動，即他們想要做的事情，比如刪除、更新、閱讀、查看等等。最後，我們有他們想要執行這些操作的資源。因此，這就像是我想閱讀所有評論，我想閱讀這些特定的評論，我想刪除這一條個別的評論，這正是資源的定義，它是你所作用的對象。

00:20:03  然後最後第四部分將包含任何其他附加資訊，例如他們屬於哪個組織、他們所處的環境、特定位置、是否在使用電話等，所有這些不同的屬性可以用來決定你希望這個特定事物的呈現方式。因此，如你所見，這看起來與我們的基於角色的訪問控制非常相似，但最大的區別在於這些部分中的每一個都有很多屬性。例如，我們的主體，我們的用戶有一個用戶ID，他們有一個特定的角色，也許他們還有一個創建日期，所有這些其他內容，我們的資源上也有其他內容，也許它有一個作者ID。

00:20:34  我們想要檢查它是否有發布日期，還有其他許多事項，例如這是草稿還是非草稿，所有這些我們可以在我們的權限中檢查，以確定我們是否想要執行這個特定的操作。這就是我們要建立的系統，因為這是迄今為止最靈活的系統，許多權限公司會收取你數千美元來使用這個系統。我將向你展示如何完全免費地建立它。所以讓我們回到代碼中，在我們實際處理這個權限系統之前，我首先想談談一些更簡單的系統，即我們如何處理組織以及如何處理多個角色，而不僅僅是用戶。

00:21:06  現在在處理組織時，擁有一個個別角色，文書工作者擁有所有這些內建功能，這非常好。你甚至可以看到這裡有一個完整的組織標籤。我可以在配置部分設置我所有不同的組織設置，特別是我的角色和權限。例如，我可以擁有管理員角色、版主角色、用戶角色以及我想要的任何其他角色，我也可以指定所有不同的權限。因此，我們在處理評論時，我擁有刪除評論的權限、閱讀評論和更新評論的權限，以及查看評論的權限，我還可以添加我想要的所有其他相關權限。

00:21:37  在這裡有一個很棒的功能，Clerk 預設添加了許多自己的權限，這些權限特別與組織的管理有關。用戶能否創建組織？他們能否添加用戶？他們能否邀請用戶？他們能否刪除用戶？他們能否更新用戶？所有與實際管理組織相關的功能都直接內建在這裡，這真的很棒，因此你不必擔心這些事情，因為老實說，這比你想的要複雜得多，尤其是當你開始處理邀請用戶、用戶同時登錄多個不同組織並在它們之間切換時，所有這些都會自動由 Clerk 處理。

00:22:09  它可以直接使用，您只需確保在這裡啟用組織，只需勾選一個選框，然後打開它，然後就可以在您的應用程式中擁有組織了。如果我們想處理多個角色，這對我們來說也非常簡單。我們可以進入特定的用戶，這將回到非組織的做法，我只需將這個從角色改為角色，然後將其更改為數組，這樣就可以正常運作了。現在，我還需要修改我的代碼以支持這一點，所以這裡將顯示角色，並且它將是一個角色數組，還有裡面的內容。

00:22:41  我想將這裡的內容改為角色，並將其設置為一個陣列，預設情況下，這個用戶唯一擁有的角色是用戶角色。然後我需要在這裡進一步修改我的代碼，這裡會顯示我所有不同的角色，而在這裡檢查我們是否有權限的地方，這也需要改變，因為這將接受一個不同角色的陣列，所以我們只想遍歷這些角色。這樣我們就可以說返回用戶的角色，確保我正確拼寫，應該是角色，這樣就好了，對每一個我的角色進行一些操作。

00:23:15  角色 我只想返回 在這裡調用這段特定的代碼，我們將傳入角色，確保我將所有這些包裹在正確的括號中，這樣就好了，我還需要在那裡再加一個括號，快速保存一下，這樣就運行得很好了。現在最後一步是在我的頁面中，我只想確保我的用戶有一個 roles 屬性，而不是一個 roll 屬性，保存一下，然後我們還想確保這也更新為 rules，然後我們還需要在這裡配置我們的會話，以確保我們傳遞下去。

00:23:46  一個角色就這樣滾動，僅僅因為我們將所有東西從“Roll”重新命名為“roll”。如果你最初設置這個時候，現在就不必經歷所有的重新命名。現在所有的工作都完成了，我們希望能夠刷新我們的頁面，如你所見，我們的角色就在最上面。如果我們給用戶多個角色，我們會在那裡看到這些多個角色。那麼讓我們來做這個，我們會去我們的特定用戶，編輯這個，然後添加第二個角色為管理員，保存一下。現在如果我們回到這裡，稍等一下並刷新一下，這樣就可以了，現在我們可以看到我們的兩個角色。

00:24:17  現在彈出來的地方就是我們要實際實施我在影片開始時提到的那個極其複雜的離線系統。讓我們直接進入，並將整個檔案貼上來，我會逐一解釋裡面的所有代碼，因為這相當複雜。首先，我們有一堆不同的類型，這是為了模擬我們數據中的所有不同類型。我們有待辦事項、有評論、有用戶和角色。如果我們查看這些類型，可以看到評論有一個ID、一個內容、一個作者ID和一個創建時間。在這裡，我們的已完成項目有一個已完成欄位、一個用戶ID、一個標題ID，甚至還有一個包含所有不同用戶的數組。

00:24:49  邀請訪問這個特定的待辦事項，因此這組特定的數據將允許我們做很多事情。首先，我們可以檢查，嘿，這是評論的作者嗎？這是創建這個待辦事項的人嗎？我們可以檢查他們是否被邀請實際訪問這個特定的數據。我們可以檢查這個待辦事項是否已完成。所有這些功能我們都可以在系統內使用。此外，對於我們的角色，您可以看到我們有管理員、版主和用戶，就像之前一樣，但對於我們的用戶，我添加了一個額外的欄位來標記被封鎖的用戶，因此我們實際上可以封鎖特定用戶，以再次進行所有這些不同的複雜身份驗證和基於權限的操作。我們可以根據權限進行管理。

00:25:20  他們被邀請了嗎？他們被阻擋了嗎？事情完成了嗎？他們是這件特定事物的作者嗎？這一切都由系統輕鬆處理。因此，回到這裡頂部的關閉部分，我這裡有一些相當複雜的 TypeScript。這段 TypeScript 唯一的作用是讓我們在這裡定義所有不同角色時，獲得完整的類型安全。例如，如果我刪除一些內容，然後進入這裡，你可以看到我在這裡的註解中獲得了類型安全。我可以獲得創建、更新或查看，當我去定義這個創建、更新或查看時，我可以傳遞一個布林值，例如 true 或 false，或者我可以傳遞一個函數。

00:25:51  這個功能也具有完整的類型安全性。例如，如果我進入這裡並訪問我的用戶，我會獲得所有用戶的類型安全性；如果我訪問我的評論，我會獲得所有評論的類型安全性。所以這就是這組特定的 TypeScript 在上面所做的。讓我把這段代碼恢復到之前的樣子，所以其實不用太擔心這個，這只是一些複雜的 TypeScript 來做到這些，可能寫得也不是很好，因為我對 TypeScript 真的不是那麼擅長。接下來我們有這個類型，叫做 permissions，這是你定義應用程式內所有不同權限的地方。所以例如，我們的第一個權限是針對評論的。

00:26:22  我將這段文字翻譯成繁體中文如下：   我將這個分解的方式是關鍵在於資源，所以在我提到的那四步系統中，我提到了資源，這就是我們的資源，我的註解。然後我指定註解的類型，這再次僅適用於 TypeScript，因此 TypeScript 可以給我很好的自動補全。我說這是一種類型的註解，在這個待辦事項中，你甚至可以看到，比如說我只想要 ID 部分，我可以直接說作者 ID，現在這就是我在這些函數中唯一能訪問的內容。因此，每當我來到這裡的註解時，你可以看到我只能訪問作者 ID，所以我可以根據需要限制它，在我的情況下，我只是保持它原樣。

00:26:54  完整的評論，然後我可以指定所有不同操作的列表，例如這只能用於查看、創建和更新，我甚至沒有刪除評論的選項，因為這不是我的應用在這個特定用例中能做的事情。這裡也是一樣，我們有待辦事項，這個讓我們可以查看、創建、更新和刪除，因此我們可以真正精細調整我們每一個不同權限的具體功能。然後你所要做的就是定義你的權限，例如在管理員的評論上，我們對所有操作都設置為真，待辦事項也是如此，我們對所有操作都設置為真。對於我們的版主，他們可以對評論執行所有操作，但對於待辦事項，例如他們可以查看、創建和更新任何他們想要的待辦事項，但他們……

00:27:25  只能刪除已完成的待辦事項，現在這種根據我們正在操作的對象實際屬性來執行某些操作的能力，只有在這種基於屬性的訪問控制系統中才能實現。在我們舊的基於角色的權限系統中，我們無法根據對象的屬性來執行操作，這需要我們在這裡進行非常大的檢查，但現在所有這些信息都定義在我的權限系統中，因此我所有的檢查都將變得非常簡單，而我處理權限的系統全部在這個文件中。同樣的情況，當我處理用戶時，情況變得更加複雜，因為現在我可以...

00:27:56  檢查許多不同的事項，例如用戶可以創建他們想要的任何評論，但他們只能查看未被封鎖他們的人的評論，因此如果一個用戶封鎖了另一個用戶，他們將不再能看到那些評論。他們也可以更新任何評論，只要他們是該評論的作者。如果我們查看待辦事項部分，你可以再次看到，只要該待辦事項未被其他人封鎖，他們就可以查看任何待辦事項。因此，如果用戶沒有封鎖他們，他們就可以查看。用戶可以更新任何他們是作者的待辦事項，或任何他們被其他用戶邀請的待辦事項，最後，他們可以刪除任何他們擁有特定ID的待辦事項，或者如果他們被邀請的話。

00:28:27  其他用戶可以刪除它，並且他們只能刪除已完成屬性設置為真的待辦事項，所以我在這裡做了一些事情來展示這一切的靈活性，顯然你可以做更多或更少的靈活性，這完全取決於你，但你幾乎可以在你的用戶、你的評論上運行任何你想要的 JavaScript 代碼，並且你也可以在這裡傳遞任何其他信息。我只是讓它相對簡單，但你可以看到它在你可以做的事情上是非常靈活的。然後我們的權限檢查函數在這裡稍微改變了，因為現在我們需要像之前一樣將其傳遞給我們的用戶。

00:28:59  將以下文本翻譯成繁體中文：行動分為兩個獨立的部分，因此現在我們可以傳遞例如看起來像這樣的東西，它會說有權限，我們將它傳遞給我們的用戶，我們將它傳遞給我們的資源，然後我們將它傳遞給下一個行動，所以它將被分成兩個獨立的參數，最後如果你想的話，你實際上可以傳遞一些數據，而這些特定的數據將是一個評論對象，因此我也可以傳遞我自己的評論對象，所以如果我不傳遞任何東西，這是在檢查我是否有能力更新數據庫中的每一條評論，如果我傳遞一個特定的對象，那就是在說我是否有能力更新這一條。

00:29:30  特定的物件，因此這個系統的運作方式非常靈活。如果我給你展示一下這是如何發生的示範，我會回到我的程式碼這裡，我將刪除這裡的所有內容，然後貼上大量的新程式碼，我會準確地展示這段程式碼的樣子。我還需要確保在這裡更改我的一個導入，以便從正確的檔案中導入，確保這裡面的所有內容都已保存。現在如果我們回到這個特定的頁面，你可以看到在最上面我有一個不同待辦事項的列表，我會把這個寬度調整得更大一點，這樣你就可以清楚地看到發生了什麼，稍微縮小一下，這樣應該對你來說非常容易。

00:30:01  所以我有一個不同待辦事項的清單，我在右側有它們。第一個待辦事項的ID是1，這是由ID為1的用戶創建的，尚未完成，沒有任何人被邀請。ID為2的待辦事項也是由用戶1創建的。因此，第一行的這兩個待辦事項都是由用戶1創建的，並且它們可能已完成或未完成。如果有一個X，表示尚未完成；如果有一個勾號，表示已完成。然後，接下來的兩個待辦事項是由用戶2創建的，而最後這個待辦事項是由用戶1和3邀請的。所以用戶1。

00:30:32  並且三個人被邀請參加那個特定的待辦事項，然後在這裡我正在定義我的用戶，我現在正在為它編寫代碼，我們稍後會實現文員，但這對我來說更容易玩弄數據以便於演示，最後我有一堆不同的按鈕檢查，所以我有這個一般的按鈕檢查，如果我們向下滾動到那個函數，你可以看到它所做的只是調用 has permission，傳遞我的用戶、資源和動作，如果我們可以執行那個動作，它會給我一個藍色按鈕，而如果我不能執行那個動作，它會給我一個紅色按鈕，所以在最上面這裡我正在檢查我是否可以執行查看、創建或更新。

00:31:03  並刪除我資料庫中所有的待辦事項，這只是一般性的問題，我可以這樣處理待辦事項嗎？如您所見，ID 為三的用戶角色為用戶，他們無法查看所有待辦事項，他們可以創建任何他們想要的待辦事項，但無法更新所有待辦事項，也無法刪除所有待辦事項。現在如果我特別將這個角色更改為管理員並保存，您現在可以看到管理員，一切都變成藍色，因為管理員在我們的應用程式中幾乎擁有所有權限。接下來我所做的是遍歷每個待辦事項，並在每個待辦事項內添加三個獨立的按鈕，以檢查是否...

00:31:35  他們有權限查看、更新和刪除特定的待辦事項。如果我們查看檢查權限的代碼，可以看到它傳遞了我的用戶信息，還有我想要檢查的項目，在我的情況下是待辦事項，還有我想要檢查的操作，是查看、刪除、更新等等。最後，我還傳遞了個別的待辦事項，這將確保我完成所有這些額外的檢查。如果我上去這裡，你可以看到我傳遞了我的待辦事項，這將調用這個特定的函數，裡面包含所有的代碼。現在讓我們回到這裡，我們可以真正玩弄這個權限系統的靈活性。

00:32:06  因為如果我們進來這裡，並且我們說我們是用戶ID為一的用戶，然後我們快速保存一下，你可以看到ID為一的用戶可以查看所有這些不同的項目，他們可以查看所有待辦事項，這是可以的，因為他們不會被任何人阻擋。他們可以更新自己創建的待辦事項，也可以刪除自己創建的已標記為完成的待辦事項。你可以看到他們被邀請參加這個特定的待辦事項，因此他們也有能力更新和刪除這個待辦事項，但對於用戶2的這個待辦事項，他們沒有權限對其進行任何操作，所以你可以看到更新和刪除被阻止了。

00:32:37  現在讓我們進入這裡，使用者3有特定的訪問權限，因為他們已被邀請。假設他們實際上已被使用者2封鎖，如果我們快速保存一下，現在你可以看到他們被阻止查看使用者2創建的任何內容，因為他們被該使用者封鎖。這裡同樣的情況，如果我們使用使用者1，你可以看到他們被阻止查看這裡的任何信息，因為他們被該使用者封鎖。現在，如果我們的使用者有多個角色，例如版主，我們不希望版主被某人封鎖。因此，如果版主是這裡的實際角色，你可以看到他們可以。

00:33:08  即使被封鎖，作為版主仍然能夠查看事物，他們應該能夠繞過這種封鎖，這就是我們設立版主的原因。你可以看到這個特定的人有多個角色，我們正在檢查多個角色如何運作。現在將這個與 clerk 實施結合起來相對簡單，我們只想確保再次獲取我們的會話聲明，因此我們可以說 const sessionClaims，這將等於調用 off 函數。這是一個異步函數，所以確保我們在這裡加上 async，我們等待這個，我將獲得。

00:33:40  用戶 ID 也是如此，這樣就好了。我在這裡說，如果我們的會話聲明等於空或我們的用戶 ID 等於空，那麼我將返回登錄按鈕，所以我會快速複製那個按鈕，這樣就好了，現在我們有了登錄按鈕。最後，我們可以實際上獲取我們的用戶，所以我們可以說用戶等於 ID 是我們的用戶 ID，而我們的角色是你的會話。

00:34:12  聲明。來吧，然後我們可以說我們被用戶阻擋了，我在這裡稱之為被阻擋了，然後我們只會說他們沒有被任何人阻擋。你可以從你的數據庫中獲取這個信息，你可以從會話聲明中獲取，你幾乎可以從任何你想要的地方獲取，但現在一切應該都能正常運作，對於我們的特定用戶對象，只要確保我們在需要的地方都傳遞了用戶。因此，我要做的就是把我的用戶作為道具傳遞，就像這樣給每一個這些。

00:34:44  因為我們需要訪問這個，這裡也是一樣，我會把它放進我的待辦事項中，因此我們可以說這個待辦事項的功能將會接收我所有的待辦屬性以及一個用戶，現在我們先把這個類型設為任何，以便我可以繞過所有的類型問題，所以這將會是任何和待辦事項，這就是待辦事項，對於那個特定的類型，我只需進來這樣做，就能解決所有這些問題，然後這裡也是一樣，我會傳入一個用戶，我會這樣做。

00:35:16  將其類型設為任何，以便我們可以繞過所有類型腳本的內容，因為這現在並不重要。我需要做的最後一件事是傳遞我的用戶，這樣就好了，將其粘貼下來，在這裡我們將再次傳遞一個用戶，暫時也設為任何類型。我相信我在這裡犯了一個錯誤，這裡不應該有類型行，這應該能解決我們的問題。好了，你可以看到這個用戶擁有用戶和管理員的角色，因此他們有權訪問所有內容，因為他們是管理員。但如果我們想修改我們的用戶，使他們不再是管理員，那就刪除。

00:35:48  現在獲得管理員權限，快速保存一下，然後回到這裡，等一會兒，我們將刷新，現在你可以看到我們是一個用戶，用戶 ID 與這些用戶 ID 不匹配，因此我們無法更新或刪除任何一個。我們可以查看它們，因為我們不會被這些人阻擋。我顯然可以修改這一點，說我們被用戶一阻擋，現在我無法再查看用戶一的內容，但我仍然可以查看用戶二的內容。我知道我在這段視頻中快速瀏覽了代碼，所以如果你想深入了解這些權限系統，我會提供一個 GitHub 倉庫的鏈接，其中包含所有這些不同的權限系統。

00:36:19  去調整它們，閱讀它們，看看它們到底是什麼。此外，如果你喜歡 Clerk，並且想要查看一個非常好的身份驗證系統，讓身份驗證變得簡單到你再也不需要思考的程度，我強烈推薦你查看 Clerk。我喜歡在我的各種項目中使用它。我會在下面的描述中留下鏈接。說到這裡，非常感謝你的觀看，祝你有美好的一天。